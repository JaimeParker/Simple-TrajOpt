#ifndef SIMPLE_TRAJECTORY_H
#define SIMPLE_TRAJECTORY_H

#include <Eigen/Eigen>
#include <vector>

// --- ABSTRACT INTERFACE (from previous discussion, remains the same) ---
/**
 * @brief An abstract base class representing a time-parameterized 3D trajectory.
 */
class SimpleTrajectory {
public:
    virtual ~SimpleTrajectory() = default;
    virtual Eigen::Vector3d getPosition(double t) const = 0;
    virtual Eigen::Vector3d getVelocity(double t) const = 0;
    virtual Eigen::Vector3d getAcceleration(double t) const = 0;
    virtual double getTotalDuration() const = 0;
};

// --- CONCRETE IMPLEMENTATION FOR DISCRETE TRAJECTORIES ---
/**
 * @brief A concrete implementation of SimpleTrajectory for discrete, time-stamped waypoints.
 *
 * This class stores a sequence of states (pos, vel, acc) and provides
 * continuous values through linear interpolation. It is highly efficient for
 * trajectories generated by guidance laws or discrete planners.
 */
class DiscreteTrajectory : public SimpleTrajectory {
public:
    // A struct to hold the full state at each discrete point in time.
    struct StateWaypoint {
        double timestamp;
        Eigen::Vector3d position;
        Eigen::Vector3d velocity;
        Eigen::Vector3d acceleration;

        // Comparator to allow sorting and searching by timestamp.
        bool operator<(const StateWaypoint& other) const {
            return timestamp < other.timestamp;
        }
    };

    // Default constructor
    DiscreteTrajectory() = default;

    /**
     * @brief Construct by taking ownership of a vector of waypoints.
     * The vector is guaranteed to be sorted after construction.
     */
    explicit DiscreteTrajectory(std::vector<StateWaypoint>&& waypoints) noexcept 
        : waypoints_(std::move(waypoints)) {
        // Ensure the waypoints are sorted by timestamp for efficient searching.
        if (!std::is_sorted(waypoints_.begin(), waypoints_.end())) {
            std::sort(waypoints_.begin(), waypoints_.end());
        }
    }

    // --- Override and Implement the Interface ---

    Eigen::Vector3d getPosition(double t) const override {
        return getStateAtTime(t).position;
    }

    Eigen::Vector3d getVelocity(double t) const override {
        return getStateAtTime(t).velocity;
    }

    Eigen::Vector3d getAcceleration(double t) const override {
        return getStateAtTime(t).acceleration;
    }

    double getTotalDuration() const override {
        return waypoints_.empty() ? 0.0 : waypoints_.back().timestamp;
    }
    
    // --- Public method to add waypoints ---
    void addWaypoint(const StateWaypoint& waypoint) {
        waypoints_.push_back(waypoint);
        // For simplicity, we assume waypoints are added in order.
        // If not, a call to sort() would be needed after adding all points.
    }

private:
    /**
     * @brief The core lookup and interpolation logic.
     * @param t The query time.
     * @return The interpolated StateWaypoint at time t.
     */
    StateWaypoint getStateAtTime(double t) const {
        if (waypoints_.empty()) {
            return StateWaypoint{0.0, Eigen::Vector3d::Zero(), Eigen::Vector3d::Zero(), Eigen::Vector3d::Zero()};
        }

        // Handle edge cases: before the start or after the end.
        if (t <= waypoints_.front().timestamp) {
            return waypoints_.front();
        }
        if (t >= waypoints_.back().timestamp) {
            return waypoints_.back();
        }

        // Find the first waypoint whose timestamp is > t using binary search.
        auto it = std::upper_bound(waypoints_.begin(), waypoints_.end(), StateWaypoint{t, {}, {}, {}});
        
        // it now points to the waypoint *after* our time t.
        // The waypoint *before* t is therefore it - 1.
        const auto& p2 = *it;
        const auto& p1 = *(it - 1);

        const double segment_duration = p2.timestamp - p1.timestamp;
        if (segment_duration < 1e-9) { // Avoid division by zero
            return p1;
        }

        // Calculate the interpolation factor, alpha.
        const double alpha = (t - p1.timestamp) / segment_duration;

        // Linearly interpolate position, velocity, and acceleration.
        StateWaypoint interpolated_state;
        interpolated_state.timestamp = t;
        interpolated_state.position = (1.0 - alpha) * p1.position + alpha * p2.position;
        interpolated_state.velocity = (1.0 - alpha) * p1.velocity + alpha * p2.velocity;
        interpolated_state.acceleration = (1.0 - alpha) * p1.acceleration + alpha * p2.acceleration;

        return interpolated_state;
    }

    std::vector<StateWaypoint> waypoints_;
};

#endif // SIMPLE_TRAJECTORY_H
