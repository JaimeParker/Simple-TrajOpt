#!/usr/bin/env python3
"""
Trajectory Visualization Script for Perching Optimization Comparison

This script loads trajectory data from CSV files generated by the C++ comparison
and creates comprehensive visualizations using matplotlib.
"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.patches as patches

def load_trajectory_data(filename):
    """Load trajectory data from CSV file."""
    try:
        # Load data using numpy
        data = np.loadtxt(filename, delimiter=',', skiprows=1)
        
        # Create a dictionary with column names for easier access
        traj_data = {
            'time': data[:, 0],
            'pos_x': data[:, 1],
            'pos_y': data[:, 2], 
            'pos_z': data[:, 3],
            'vel_x': data[:, 4],
            'vel_y': data[:, 5],
            'vel_z': data[:, 6],
            'acc_x': data[:, 7],
            'acc_y': data[:, 8],
            'acc_z': data[:, 9]
        }
        
        print(f"Loaded {filename}: {len(data)} data points, duration: {traj_data['time'][-1]:.2f}s")
        return traj_data
    except FileNotFoundError:
        print(f"Error: Could not find {filename}")
        return None
    except Exception as e:
        print(f"Error loading {filename}: {e}")
        return None

def create_comprehensive_visualization(traj1_data, traj2_data):
    """Create a comprehensive comparison visualization."""
    
    # Set up the figure with subplots
    fig = plt.figure(figsize=(20, 16))
    
    # Color scheme
    color1 = '#1f77b4'  # Blue for original
    color2 = '#ff7f0e'  # Orange for refactored
    
    # 3D trajectory plot (main plot)
    ax1 = fig.add_subplot(2, 3, 1, projection='3d')
    
    # Plot trajectories
    ax1.plot(traj1_data['pos_x'], traj1_data['pos_y'], traj1_data['pos_z'], 
             color=color1, linewidth=2, label='Original TrajOpt', alpha=0.8)
    ax1.plot(traj2_data['pos_x'], traj2_data['pos_y'], traj2_data['pos_z'], 
             color=color2, linewidth=2, label='PerchingOptimizer', alpha=0.8)
    
    # Mark start and end points
    ax1.scatter(traj1_data['pos_x'][0], traj1_data['pos_y'][0], traj1_data['pos_z'][0], 
                color='green', s=100, marker='o', label='Start')
    ax1.scatter(traj1_data['pos_x'][-1], traj1_data['pos_y'][-1], traj1_data['pos_z'][-1], 
                color='red', s=100, marker='s', label='Original End')
    ax1.scatter(traj2_data['pos_x'][-1], traj2_data['pos_y'][-1], traj2_data['pos_z'][-1], 
                color='darkred', s=100, marker='^', label='Refactored End')
    
    # Add target trajectory (moving platform)
    target_start = np.array([8.0, 2.0, 1.0])
    target_vel = np.array([1.5, 0.5, 0.0])
    max_time = max(traj1_data['time'].max(), traj2_data['time'].max())
    target_end = target_start + target_vel * max_time
    
    ax1.plot([target_start[0], target_end[0]], [target_start[1], target_end[1]], 
             [target_start[2], target_end[2]], 'k--', linewidth=2, label='Target Path', alpha=0.7)
    ax1.scatter(*target_start, color='purple', s=150, marker='D', label='Target Start')
    ax1.scatter(*target_end, color='magenta', s=150, marker='D', label='Target End')
    
    ax1.set_xlabel('X Position (m)')
    ax1.set_ylabel('Y Position (m)')
    ax1.set_zlabel('Z Position (m)')
    ax1.set_title('3D Trajectory Comparison\nPerching Maneuver', fontsize=14, fontweight='bold')
    ax1.legend(loc='upper right', bbox_to_anchor=(1.3, 1.0))
    ax1.grid(True, alpha=0.3)
    
    # Position components over time
    ax2 = fig.add_subplot(2, 3, 2)
    ax2.plot(traj1_data['time'], traj1_data['pos_x'], color=color1, linewidth=2, label='Original X')
    ax2.plot(traj1_data['time'], traj1_data['pos_y'], color=color1, linewidth=2, linestyle='--', label='Original Y')
    ax2.plot(traj1_data['time'], traj1_data['pos_z'], color=color1, linewidth=2, linestyle=':', label='Original Z')
    
    ax2.plot(traj2_data['time'], traj2_data['pos_x'], color=color2, linewidth=2, label='Refactored X')
    ax2.plot(traj2_data['time'], traj2_data['pos_y'], color=color2, linewidth=2, linestyle='--', label='Refactored Y')
    ax2.plot(traj2_data['time'], traj2_data['pos_z'], color=color2, linewidth=2, linestyle=':', label='Refactored Z')
    
    ax2.set_xlabel('Time (s)')
    ax2.set_ylabel('Position (m)')
    ax2.set_title('Position Components vs Time', fontweight='bold')
    ax2.legend()
    ax2.grid(True, alpha=0.3)
    
    # Velocity components over time
    ax3 = fig.add_subplot(2, 3, 3)
    ax3.plot(traj1_data['time'], traj1_data['vel_x'], color=color1, linewidth=2, label='Original X')
    ax3.plot(traj1_data['time'], traj1_data['vel_y'], color=color1, linewidth=2, linestyle='--', label='Original Y')
    ax3.plot(traj1_data['time'], traj1_data['vel_z'], color=color1, linewidth=2, linestyle=':', label='Original Z')
    
    ax3.plot(traj2_data['time'], traj2_data['vel_x'], color=color2, linewidth=2, label='Refactored X')
    ax3.plot(traj2_data['time'], traj2_data['vel_y'], color=color2, linewidth=2, linestyle='--', label='Refactored Y')
    ax3.plot(traj2_data['time'], traj2_data['vel_z'], color=color2, linewidth=2, linestyle=':', label='Refactored Z')
    
    ax3.set_xlabel('Time (s)')
    ax3.set_ylabel('Velocity (m/s)')
    ax3.set_title('Velocity Components vs Time', fontweight='bold')
    ax3.legend()
    ax3.grid(True, alpha=0.3)
    
    # Acceleration magnitude over time
    ax4 = fig.add_subplot(2, 3, 4)
    
    # Calculate acceleration magnitudes
    acc_mag1 = np.sqrt(traj1_data['acc_x']**2 + traj1_data['acc_y']**2 + traj1_data['acc_z']**2)
    acc_mag2 = np.sqrt(traj2_data['acc_x']**2 + traj2_data['acc_y']**2 + traj2_data['acc_z']**2)
    
    ax4.plot(traj1_data['time'], acc_mag1, color=color1, linewidth=2, label='Original')
    ax4.plot(traj2_data['time'], acc_mag2, color=color2, linewidth=2, label='Refactored')
    
    # Add dynamic limits line (assuming 10 m/s² from the C++ code)
    ax4.axhline(y=10.0, color='red', linestyle='--', alpha=0.7, label='Limit (10 m/s²)')
    
    ax4.set_xlabel('Time (s)')
    ax4.set_ylabel('Acceleration Magnitude (m/s²)')
    ax4.set_title('Acceleration Magnitude vs Time', fontweight='bold')
    ax4.legend()
    ax4.grid(True, alpha=0.3)
    
    # Position difference over time
    ax5 = fig.add_subplot(2, 3, 5)
    
    # Interpolate to common time base for comparison
    common_time = np.linspace(0, min(traj1_data['time'][-1], traj2_data['time'][-1]), 1000)
    
    pos1_interp_x = np.interp(common_time, traj1_data['time'], traj1_data['pos_x'])
    pos1_interp_y = np.interp(common_time, traj1_data['time'], traj1_data['pos_y'])
    pos1_interp_z = np.interp(common_time, traj1_data['time'], traj1_data['pos_z'])
    
    pos2_interp_x = np.interp(common_time, traj2_data['time'], traj2_data['pos_x'])
    pos2_interp_y = np.interp(common_time, traj2_data['time'], traj2_data['pos_y'])
    pos2_interp_z = np.interp(common_time, traj2_data['time'], traj2_data['pos_z'])
    
    pos_diff = np.sqrt((pos1_interp_x - pos2_interp_x)**2 + 
                       (pos1_interp_y - pos2_interp_y)**2 + 
                       (pos1_interp_z - pos2_interp_z)**2)
    
    ax5.plot(common_time, pos_diff, color='purple', linewidth=2)
    ax5.fill_between(common_time, pos_diff, alpha=0.3, color='purple')
    
    ax5.set_xlabel('Time (s)')
    ax5.set_ylabel('Position Difference (m)')
    ax5.set_title('Position Difference Between Trajectories', fontweight='bold')
    ax5.grid(True, alpha=0.3)
    
    # Add statistics text
    max_diff = pos_diff.max()
    mean_diff = pos_diff.mean()
    ax5.text(0.02, 0.98, f'Max: {max_diff:.3f}m\nMean: {mean_diff:.3f}m', 
             transform=ax5.transAxes, verticalalignment='top',
             bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.8))
    
    # Top view (X-Y plane)
    ax6 = fig.add_subplot(2, 3, 6)
    
    # Plot trajectories in X-Y plane
    ax6.plot(traj1_data['pos_x'], traj1_data['pos_y'], color=color1, linewidth=2, 
             label='Original', alpha=0.8)
    ax6.plot(traj2_data['pos_x'], traj2_data['pos_y'], color=color2, linewidth=2, 
             label='Refactored', alpha=0.8)
    
    # Add target path
    ax6.plot([target_start[0], target_end[0]], [target_start[1], target_end[1]], 
             'k--', linewidth=2, label='Target Path', alpha=0.7)
    
    # Mark key points
    ax6.scatter(traj1_data['pos_x'][0], traj1_data['pos_y'][0], 
                color='green', s=100, marker='o', label='Start', zorder=10)
    ax6.scatter(traj1_data['pos_x'][-1], traj1_data['pos_y'][-1], 
                color='red', s=100, marker='s', label='Original End', zorder=10)
    ax6.scatter(traj2_data['pos_x'][-1], traj2_data['pos_y'][-1], 
                color='darkred', s=100, marker='^', label='Refactored End', zorder=10)
    
    # Add platform representation
    platform_radius = 0.5  # From C++ code
    circle1 = patches.Circle((traj1_data['pos_x'][-1], traj1_data['pos_y'][-1]), 
                            platform_radius, fill=False, linestyle='-', 
                            edgecolor='red', linewidth=2, alpha=0.5)
    circle2 = patches.Circle((traj2_data['pos_x'][-1], traj2_data['pos_y'][-1]), 
                            platform_radius, fill=False, linestyle='--', 
                            edgecolor='darkred', linewidth=2, alpha=0.5)
    ax6.add_patch(circle1)
    ax6.add_patch(circle2)
    
    ax6.set_xlabel('X Position (m)')
    ax6.set_ylabel('Y Position (m)')
    ax6.set_title('Top View (X-Y Plane)', fontweight='bold')
    ax6.legend()
    ax6.grid(True, alpha=0.3)
    ax6.set_aspect('equal', adjustable='box')
    
    plt.tight_layout()
    return fig

def print_trajectory_statistics(traj1_data, traj2_data):
    """Print detailed comparison statistics."""
    print("\n" + "="*60)
    print("TRAJECTORY COMPARISON STATISTICS")
    print("="*60)
    
    print(f"\n📊 Basic Statistics:")
    print(f"  Original Trajectory:")
    print(f"    Duration: {traj1_data['time'][-1]:.3f}s")
    print(f"    Data points: {len(traj1_data['time'])}")
    print(f"    Final position: ({traj1_data['pos_x'][-1]:.3f}, {traj1_data['pos_y'][-1]:.3f}, {traj1_data['pos_z'][-1]:.3f})")
    
    print(f"\n  Refactored Trajectory:")
    print(f"    Duration: {traj2_data['time'][-1]:.3f}s")
    print(f"    Data points: {len(traj2_data['time'])}")
    print(f"    Final position: ({traj2_data['pos_x'][-1]:.3f}, {traj2_data['pos_y'][-1]:.3f}, {traj2_data['pos_z'][-1]:.3f})")
    
    # Calculate differences at common time points
    common_time = np.linspace(0, min(traj1_data['time'][-1], traj2_data['time'][-1]), 1000)
    
    pos1_x = np.interp(common_time, traj1_data['time'], traj1_data['pos_x'])
    pos1_y = np.interp(common_time, traj1_data['time'], traj1_data['pos_y'])
    pos1_z = np.interp(common_time, traj1_data['time'], traj1_data['pos_z'])
    
    pos2_x = np.interp(common_time, traj2_data['time'], traj2_data['pos_x'])
    pos2_y = np.interp(common_time, traj2_data['time'], traj2_data['pos_y'])
    pos2_z = np.interp(common_time, traj2_data['time'], traj2_data['pos_z'])
    
    pos_diff = np.sqrt((pos1_x - pos2_x)**2 + (pos1_y - pos2_y)**2 + (pos1_z - pos2_z)**2)
    
    print(f"\n📏 Position Differences:")
    print(f"    Maximum difference: {pos_diff.max():.6f}m")
    print(f"    Mean difference: {pos_diff.mean():.6f}m")
    print(f"    Standard deviation: {pos_diff.std():.6f}m")
    print(f"    RMS difference: {np.sqrt(np.mean(pos_diff**2)):.6f}m")
    
    # Final position difference
    final_diff = np.sqrt((traj1_data['pos_x'][-1] - traj2_data['pos_x'][-1])**2 + 
                        (traj1_data['pos_y'][-1] - traj2_data['pos_y'][-1])**2 + 
                        (traj1_data['pos_z'][-1] - traj2_data['pos_z'][-1])**2)
    
    print(f"    Final position difference: {final_diff:.6f}m")
    
    # Velocity and acceleration statistics
    vel1_max = np.sqrt(traj1_data['vel_x']**2 + traj1_data['vel_y']**2 + traj1_data['vel_z']**2).max()
    vel2_max = np.sqrt(traj2_data['vel_x']**2 + traj2_data['vel_y']**2 + traj2_data['vel_z']**2).max()
    
    acc1_max = np.sqrt(traj1_data['acc_x']**2 + traj1_data['acc_y']**2 + traj1_data['acc_z']**2).max()
    acc2_max = np.sqrt(traj2_data['acc_x']**2 + traj2_data['acc_y']**2 + traj2_data['acc_z']**2).max()
    
    print(f"\n🚀 Dynamic Characteristics:")
    print(f"    Original max velocity: {vel1_max:.3f}m/s")
    print(f"    Refactored max velocity: {vel2_max:.3f}m/s")
    print(f"    Original max acceleration: {acc1_max:.3f}m/s²")
    print(f"    Refactored max acceleration: {acc2_max:.3f}m/s²")

def main():
    """Main function to load data and create visualizations."""
    print("🚁 Perching Trajectory Visualization Tool")
    print("=" * 50)
    
    # Load trajectory data
    traj1_data = load_trajectory_data('../assets/original_trajectory.csv')
    traj2_data = load_trajectory_data('../assets/perching_optimizer_trajectory.csv')
    
    if traj1_data is None or traj2_data is None:
        print("❌ Error: Could not load trajectory data files.")
        print("Make sure to run the C++ comparison first to generate CSV files.")
        return
    
    # Print statistics
    print_trajectory_statistics(traj1_data, traj2_data)
    
    # Create visualization
    print(f"\n🎨 Creating comprehensive visualization...")
    fig = create_comprehensive_visualization(traj1_data, traj2_data)
    
    # Save the plot
    output_filename = '../assets/trajectory_comparison.png'
    fig.savefig(output_filename, dpi=300, bbox_inches='tight', 
                facecolor='white', edgecolor='none')
    print(f"📊 Visualization saved as: {output_filename}")
    
    # Show the plot
    print(f"🖥️  Displaying interactive plot...")
    plt.show()
    
    print(f"\n✅ Visualization complete!")

if __name__ == "__main__":
    main()